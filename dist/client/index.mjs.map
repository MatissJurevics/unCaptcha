{"version":3,"sources":["../../src/core/encoding.ts","../../src/client/executor.ts","../../src/client/solver.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * Encoding utilities for unCaptcha challenges\n */\n\nimport type { EncodingType } from './types';\n\n/**\n * Encode a value using the specified encoding\n */\nexport function encode(value: string, encoding: EncodingType): string {\n    switch (encoding) {\n        case 'plain':\n            return value;\n        case 'base64':\n            return encodeBase64(value);\n        case 'hex':\n            return encodeHex(value);\n        case 'rot13':\n            return encodeRot13(value);\n        default:\n            throw new Error(`Unknown encoding type: ${encoding}`);\n    }\n}\n\n/**\n * Decode a value using the specified encoding\n */\nexport function decode(value: string, encoding: EncodingType): string {\n    switch (encoding) {\n        case 'plain':\n            return value;\n        case 'base64':\n            return decodeBase64(value);\n        case 'hex':\n            return decodeHex(value);\n        case 'rot13':\n            return decodeRot13(value); // ROT13 is symmetric\n        default:\n            throw new Error(`Unknown encoding type: ${encoding}`);\n    }\n}\n\n/**\n * Base64 encode a string\n */\nexport function encodeBase64(value: string): string {\n    return Buffer.from(value, 'utf-8').toString('base64');\n}\n\n/**\n * Base64 decode a string\n */\nexport function decodeBase64(value: string): string {\n    return Buffer.from(value, 'base64').toString('utf-8');\n}\n\n/**\n * Hex encode a string\n */\nexport function encodeHex(value: string): string {\n    return Buffer.from(value, 'utf-8').toString('hex');\n}\n\n/**\n * Hex decode a string\n */\nexport function decodeHex(value: string): string {\n    return Buffer.from(value, 'hex').toString('utf-8');\n}\n\n/**\n * ROT13 encode/decode a string (symmetric cipher)\n */\nexport function encodeRot13(value: string): string {\n    return value.replace(/[a-zA-Z]/g, (char) => {\n        const base = char <= 'Z' ? 65 : 97;\n        return String.fromCharCode(((char.charCodeAt(0) - base + 13) % 26) + base);\n    });\n}\n\n/**\n * ROT13 decode (same as encode, symmetric)\n */\nexport function decodeRot13(value: string): string {\n    return encodeRot13(value);\n}\n\n/**\n * Apply multiple encoding layers\n */\nexport function encodeChain(value: string, encodings: EncodingType[]): string {\n    return encodings.reduce((acc, encoding) => encode(acc, encoding), value);\n}\n\n/**\n * Decode multiple encoding layers (in reverse order)\n */\nexport function decodeChain(value: string, encodings: EncodingType[]): string {\n    return [...encodings].reverse().reduce((acc, encoding) => decode(acc, encoding), value);\n}\n","/**\n * Safe code executor for client-side challenge solving\n */\n\nimport type {\n    ChallengePayload,\n    FunctionExecutionPayload,\n    ChainedOperationsPayload,\n    EncodedInstructionPayload,\n    PatternExtractionPayload,\n    CodeTransformPayload,\n} from '../core/types';\nimport { decode } from '../core/encoding';\n\n/**\n * Execute a function from code string\n * Uses Function constructor for sandboxed execution\n */\nexport function executeFunction(code: string, params: unknown[]): unknown {\n    try {\n        // Create a function from the code\n        // The code should define a function, so we wrap it to return the function\n        const wrapper = new Function(`\n      ${code}\n      return ${extractFunctionName(code)};\n    `);\n\n        const fn = wrapper();\n        return fn(...params);\n    } catch (error) {\n        throw new Error(`Failed to execute function: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n\n/**\n * Extract function name from function code\n */\nfunction extractFunctionName(code: string): string {\n    const match = code.match(/function\\s+(\\w+)/);\n    if (match) {\n        return match[1];\n    }\n    throw new Error('Could not extract function name from code');\n}\n\n/**\n * Execute chained operations\n */\nexport function executeChainedOperations(\n    initialValue: number,\n    operations: ChainedOperationsPayload['operations']\n): number {\n    let result = initialValue;\n\n    for (const op of operations) {\n        switch (op.operation) {\n            case 'add':\n                result += op.value ?? 0;\n                break;\n            case 'subtract':\n                result -= op.value ?? 0;\n                break;\n            case 'multiply':\n                result *= op.value ?? 1;\n                break;\n            case 'divide':\n                if (op.value === 0) throw new Error('Division by zero');\n                result /= op.value ?? 1;\n                break;\n            case 'modulo':\n                if (op.value === 0) throw new Error('Modulo by zero');\n                result %= op.value ?? 1;\n                break;\n            case 'power':\n                result = Math.pow(result, op.value ?? 1);\n                break;\n            case 'floor':\n                result = Math.floor(result);\n                break;\n            case 'ceil':\n                result = Math.ceil(result);\n                break;\n            case 'abs':\n                result = Math.abs(result);\n                break;\n            case 'negate':\n                result = -result;\n                break;\n            default:\n                throw new Error(`Unknown operation: ${(op as { operation: string }).operation}`);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Parse and execute encoded instructions\n */\nexport function executeEncodedInstruction(\n    encodedInstruction: string,\n    encoding: string\n): unknown {\n    // Decode the instruction\n    const instruction = decode(encodedInstruction, encoding as 'plain' | 'base64' | 'hex' | 'rot13');\n\n    // Parse the instruction\n    // Format: \"Calculate: A op B\"\n    const match = instruction.match(/Calculate:\\s*(\\d+)\\s*([+\\-*\\/])\\s*(\\d+)/);\n\n    if (!match) {\n        throw new Error(`Could not parse instruction: ${instruction}`);\n    }\n\n    const a = parseInt(match[1], 10);\n    const op = match[2];\n    const b = parseInt(match[3], 10);\n\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n        default:\n            throw new Error(`Unknown operator: ${op}`);\n    }\n}\n\n/**\n * Execute pattern extraction query\n */\nexport function executePatternExtraction(\n    data: Record<string, unknown>,\n    query: string\n): unknown {\n    // Simple query parser for common patterns\n    // Supports: sum(path), max(path), min(path), count(path), avg(path)\n\n    const funcMatch = query.match(/^(\\w+)\\(([^)]+)\\)$/);\n    if (!funcMatch) {\n        throw new Error(`Invalid query format: ${query}`);\n    }\n\n    const [, func, path] = funcMatch;\n\n    // Extract values from path\n    // Supports: items[*].value, items, etc.\n    const values = extractPathValues(data, path);\n\n    switch (func.toLowerCase()) {\n        case 'sum':\n            return (values as number[]).reduce((a, b) => a + b, 0);\n        case 'max':\n            return Math.max(...(values as number[]));\n        case 'min':\n            return Math.min(...(values as number[]));\n        case 'count':\n            return (values as unknown[]).length;\n        case 'avg':\n            const nums = values as number[];\n            return nums.reduce((a, b) => a + b, 0) / nums.length;\n        default:\n            throw new Error(`Unknown function: ${func}`);\n    }\n}\n\n/**\n * Extract values from a path expression\n */\nfunction extractPathValues(data: Record<string, unknown>, path: string): unknown[] {\n    // Handle array wildcard notation: items[*].value\n    const wildcardMatch = path.match(/^(\\w+)\\[\\*\\]\\.(\\w+)$/);\n\n    if (wildcardMatch) {\n        const [, arrayName, propName] = wildcardMatch;\n        const arr = data[arrayName];\n\n        if (!Array.isArray(arr)) {\n            throw new Error(`Expected array at ${arrayName}`);\n        }\n\n        return arr.map((item: Record<string, unknown>) => item[propName]);\n    }\n\n    // Handle simple path: items\n    if (path in data) {\n        const value = data[path];\n        return Array.isArray(value) ? value : [value];\n    }\n\n    throw new Error(`Invalid path: ${path}`);\n}\n\n/**\n * Execute code transform\n */\nexport function executeCodeTransform(\n    code: string,\n    transform: string\n): unknown {\n    // Execute the code\n    const fn = new Function(code);\n    const result = fn();\n\n    switch (transform) {\n        case 'execute':\n            return result;\n        case 'execute_and_base64':\n            return Buffer.from(String(result)).toString('base64');\n        case 'execute_and_hash':\n            // Simple hash for client-side\n            const str = String(result);\n            let hash = 0;\n            for (let i = 0; i < str.length; i++) {\n                const char = str.charCodeAt(i);\n                hash = ((hash << 5) - hash) + char;\n                hash = hash & hash;\n            }\n            return Math.abs(hash).toString(16);\n        default:\n            throw new Error(`Unknown transform: ${transform}`);\n    }\n}\n\n/**\n * Execute any challenge payload and return the result\n */\nexport function executePayload(payload: ChallengePayload): unknown {\n    switch (payload.type) {\n        case 'function_execution': {\n            const p = payload as FunctionExecutionPayload;\n            return executeFunction(p.functionCode, p.parameters);\n        }\n        case 'chained_operations': {\n            const p = payload as ChainedOperationsPayload;\n            return executeChainedOperations(p.initialValue, p.operations);\n        }\n        case 'encoded_instruction': {\n            const p = payload as EncodedInstructionPayload;\n            return executeEncodedInstruction(p.instruction, p.instructionEncoding);\n        }\n        case 'pattern_extraction': {\n            const p = payload as PatternExtractionPayload;\n            return executePatternExtraction(p.data, p.query);\n        }\n        case 'code_transform': {\n            const p = payload as CodeTransformPayload;\n            return executeCodeTransform(p.code, p.transform);\n        }\n        default:\n            throw new Error(`Unknown challenge type: ${(payload as { type: string }).type}`);\n    }\n}\n","/**\n * Challenge solver for AI agents\n */\n\nimport type { Challenge, ChallengePayload } from '../core/types';\nimport { encode } from '../core/encoding';\nimport { executePayload } from './executor';\n\n/**\n * Solver options\n */\nexport interface SolverOptions {\n    /** Timeout for solving (ms) */\n    timeout?: number;\n    /** Enable debug logging */\n    debug?: boolean;\n}\n\n/**\n * Solution result\n */\nexport interface SolutionResult {\n    /** The computed solution */\n    solution: string;\n    /** Time taken to solve (ms) */\n    solveDuration: number;\n    /** Whether the solve was successful */\n    success: boolean;\n    /** Error message if failed */\n    error?: string;\n}\n\n/**\n * UnCaptcha Solver for AI agents\n */\nexport class UnCaptchaSolver {\n    private options: Required<SolverOptions>;\n\n    constructor(options?: SolverOptions) {\n        this.options = {\n            timeout: options?.timeout ?? 10000,\n            debug: options?.debug ?? false,\n        };\n    }\n\n    /**\n     * Solve a challenge\n     */\n    solve(challenge: Challenge): SolutionResult {\n        const startTime = Date.now();\n\n        try {\n            // Check if challenge is expired\n            if (Date.now() > challenge.expiresAt) {\n                return {\n                    solution: '',\n                    solveDuration: Date.now() - startTime,\n                    success: false,\n                    error: 'Challenge has expired',\n                };\n            }\n\n            if (this.options.debug) {\n                console.log(`[UnCaptcha] Solving ${challenge.type} challenge...`);\n            }\n\n            // Execute the payload to get the raw result\n            const rawResult = executePayload(challenge.payload);\n\n            // Encode the result according to the challenge's response encoding\n            const responseEncoding = (challenge.payload as ChallengePayload & { responseEncoding?: string }).responseEncoding || 'plain';\n            const solution = encode(String(rawResult), responseEncoding as 'plain' | 'base64' | 'hex' | 'rot13');\n\n            const duration = Date.now() - startTime;\n\n            if (this.options.debug) {\n                console.log(`[UnCaptcha] Solved in ${duration}ms`);\n            }\n\n            return {\n                solution,\n                solveDuration: duration,\n                success: true,\n            };\n        } catch (error) {\n            const duration = Date.now() - startTime;\n            const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n            if (this.options.debug) {\n                console.error(`[UnCaptcha] Failed to solve: ${errorMessage}`);\n            }\n\n            return {\n                solution: '',\n                solveDuration: duration,\n                success: false,\n                error: errorMessage,\n            };\n        }\n    }\n\n    /**\n     * Solve a challenge and return formatted headers for HTTP request\n     */\n    solveForRequest(challenge: Challenge): {\n        headers: Record<string, string>;\n        body: { _unCaptchaChallenge: Challenge };\n        success: boolean;\n        error?: string;\n    } {\n        const result = this.solve(challenge);\n\n        if (!result.success) {\n            return {\n                headers: {},\n                body: { _unCaptchaChallenge: challenge },\n                success: false,\n                error: result.error,\n            };\n        }\n\n        return {\n            headers: {\n                'x-uncaptcha-id': challenge.id,\n                'x-uncaptcha-solution': result.solution,\n            },\n            body: {\n                _unCaptchaChallenge: challenge,\n            },\n            success: true,\n        };\n    }\n\n    /**\n     * Fetch a challenge from a server and solve it\n     */\n    async fetchAndSolve(\n        challengeUrl: string,\n        fetchOptions?: RequestInit\n    ): Promise<{\n        challenge: Challenge;\n        solution: string;\n        success: boolean;\n        error?: string;\n    }> {\n        try {\n            const response = await fetch(challengeUrl, {\n                method: 'GET',\n                ...fetchOptions,\n            });\n\n            if (!response.ok) {\n                throw new Error(`Failed to fetch challenge: ${response.statusText}`);\n            }\n\n            const data = await response.json() as { success?: boolean; challenge?: Challenge; error?: string };\n\n            if (!data.success || !data.challenge) {\n                throw new Error(data.error || 'Invalid challenge response');\n            }\n\n            const challenge = data.challenge;\n            const result = this.solve(challenge);\n\n            return {\n                challenge,\n                solution: result.solution,\n                success: result.success,\n                error: result.error,\n            };\n        } catch (error) {\n            return {\n                challenge: null as unknown as Challenge,\n                solution: '',\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error',\n            };\n        }\n    }\n\n    /**\n     * Complete a protected request including challenge solving\n     */\n    async completeProtectedRequest(\n        challengeUrl: string,\n        protectedUrl: string,\n        requestOptions?: RequestInit\n    ): Promise<Response> {\n        // Fetch and solve the challenge\n        const { challenge, solution, success, error } = await this.fetchAndSolve(challengeUrl);\n\n        if (!success) {\n            throw new Error(`Failed to solve challenge: ${error}`);\n        }\n\n        // Make the protected request\n        const headers = new Headers(requestOptions?.headers);\n        headers.set('x-uncaptcha-id', challenge.id);\n        headers.set('x-uncaptcha-solution', solution);\n        headers.set('Content-Type', 'application/json');\n\n        const body = requestOptions?.body\n            ? { ...JSON.parse(requestOptions.body as string), _unCaptchaChallenge: challenge }\n            : { _unCaptchaChallenge: challenge };\n\n        return fetch(protectedUrl, {\n            ...requestOptions,\n            headers,\n            body: JSON.stringify(body),\n        });\n    }\n}\n\n/**\n * Create a solver instance\n */\nexport function createSolver(options?: SolverOptions): UnCaptchaSolver {\n    return new UnCaptchaSolver(options);\n}\n"]}